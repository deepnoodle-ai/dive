# Event Streaming Guide

Event streaming in Dive provides real-time visibility into agent activities, workflow execution, and system operations. This guide covers how to implement event-driven architectures, monitor system behavior, and build responsive user interfaces.

## 📋 Table of Contents

- [What is Event Streaming?](#what-is-event-streaming)
- [Event Types](#event-types)
- [Basic Event Handling](#basic-event-handling)
- [Workflow Event Streaming](#workflow-event-streaming)
- [Real-time UI Updates](#real-time-ui-updates)
- [Event Aggregation](#event-aggregation)
- [Monitoring and Alerting](#monitoring-and-alerting)
- [Best Practices](#best-practices)

## What is Event Streaming?

Event streaming in Dive enables:

- **Real-time Monitoring** - Watch agents and workflows as they execute
- **Responsive UIs** - Update interfaces immediately as events occur  
- **System Observability** - Track performance, errors, and usage patterns
- **Event-Driven Architecture** - Build reactive systems that respond to events
- **Debugging and Analysis** - Detailed insight into system behavior

### Event Flow Architecture

```
Agent/Workflow → Event Publisher → Event Stream → Event Handlers → UI/Monitoring
```

### Common Use Cases

1. **Progress Indicators** - Show real-time progress in UIs
2. **System Monitoring** - Track agent performance and health
3. **Audit Trails** - Log all agent actions for compliance
4. **Error Alerting** - Immediate notification of failures
5. **Analytics** - Collect usage data for optimization

## Event Types

### Agent Response Events

Generated during agent interactions:

```go
type ResponseEventType string

const (
    EventTypeResponseCreated     ResponseEventType = "response.created"
    EventTypeResponseInProgress  ResponseEventType = "response.in_progress"
    EventTypeResponseCompleted   ResponseEventType = "response.completed"
    EventTypeResponseFailed      ResponseEventType = "response.failed"
    EventTypeResponseToolCall    ResponseEventType = "response.tool_call"
    EventTypeResponseToolResult  ResponseEventType = "response.tool_result"
    EventTypeLLMEvent           ResponseEventType = "llm.event"
)
```

### Workflow Execution Events

Generated during workflow execution:

```go
type WorkflowEventType string

const (
    EventTypeExecutionStarted    WorkflowEventType = "execution.started"
    EventTypeExecutionCompleted  WorkflowEventType = "execution.completed" 
    EventTypeExecutionFailed     WorkflowEventType = "execution.failed"
    EventTypeStepStarted         WorkflowEventType = "step.started"
    EventTypeStepCompleted       WorkflowEventType = "step.completed"
    EventTypeStepFailed          WorkflowEventType = "step.failed"
    EventTypeStateUpdated        WorkflowEventType = "state.updated"
)
```

### Environment Events

Generated by environment operations:

```go
type EnvironmentEventType string

const (
    EventTypeAgentAdded          EnvironmentEventType = "agent.added"
    EventTypeAgentRemoved        EnvironmentEventType = "agent.removed"
    EventTypeWorkflowRegistered  EnvironmentEventType = "workflow.registered"
    EventTypeMCPConnected        EnvironmentEventType = "mcp.connected"
    EventTypeMCPDisconnected     EnvironmentEventType = "mcp.disconnected"
)
```

## Basic Event Handling

### Simple Event Callback

```go
package main

import (
    "context"
    "fmt"
    "log"

    "github.com/diveagents/dive"
    "github.com/diveagents/dive/agent"
    "github.com/diveagents/dive/llm/providers/anthropic"
)

func main() {
    agent, err := agent.New(agent.Options{
        Name:         "Event Demo Agent",
        Instructions: "You are a helpful assistant.",
        Model:        anthropic.New(),
    })
    if err != nil {
        log.Fatal(err)
    }

    // Create event callback function
    eventHandler := func(ctx context.Context, event *dive.ResponseEvent) error {
        switch event.Type {
        case dive.EventTypeResponseCreated:
            fmt.Printf("🚀 Response started (ID: %s)\n", event.Response.ID)
            
        case dive.EventTypeResponseInProgress:
            if event.Item != nil && event.Item.Message != nil {
                fmt.Printf("💭 Thinking: %s\n", event.Item.Message.Text())
            }
            
        case dive.EventTypeResponseToolCall:
            if event.Item != nil && event.Item.ToolCall != nil {
                fmt.Printf("🔧 Using tool: %s\n", event.Item.ToolCall.Name)
            }
            
        case dive.EventTypeResponseToolResult:
            if event.Item != nil && event.Item.ToolCallResult != nil {
                fmt.Printf("✅ Tool result: %s\n", event.Item.ToolCallResult.Name)
            }
            
        case dive.EventTypeResponseCompleted:
            fmt.Printf("🎉 Response completed (ID: %s)\n", event.Response.ID)
            if event.Response.Usage != nil {
                fmt.Printf("   Tokens: %d input, %d output\n", 
                          event.Response.Usage.InputTokens,
                          event.Response.Usage.OutputTokens)
            }
            
        case dive.EventTypeResponseFailed:
            fmt.Printf("❌ Response failed: %v\n", event.Error)
            
        case dive.EventTypeLLMEvent:
            if event.Item.Event.Type == "content_block_delta" {
                fmt.Print(event.Item.Event.Delta.Text)
            }
        }
        
        return nil
    }

    // Use agent with event callback
    response, err := agent.CreateResponse(
        context.Background(),
        dive.WithInput("Tell me about artificial intelligence"),
        dive.WithEventCallback(eventHandler),
    )
    if err != nil {
        log.Fatal(err)
    }

    fmt.Println("\nFinal response:")
    fmt.Println(response.Text())
}
```

### Streaming Events

```go
func demonstrateStreaming() {
    agent, err := agent.New(agent.Options{
        Name:  "Streaming Agent",
        Model: anthropic.New(),
    })
    if err != nil {
        panic(err)
    }

    // Create streaming response
    stream, err := agent.StreamResponse(
        context.Background(),
        dive.WithInput("Write a short story about AI"),
    )
    if err != nil {
        panic(err)
    }
    defer stream.Close()

    fmt.Println("Streaming response:")
    fmt.Println("==================")

    // Process events as they arrive
    for event := range stream.Events() {
        switch event.Type {
        case dive.EventTypeResponseCreated:
            fmt.Println("📝 Starting to write story...")
            
        case dive.EventTypeLLMEvent:
            // Stream text content in real-time
            if event.Item.Event.Type == "content_block_delta" {
                fmt.Print(event.Item.Event.Delta.Text)
            }
            
        case dive.EventTypeResponseCompleted:
            fmt.Println("\n\n✨ Story completed!")
            
        case dive.EventTypeResponseFailed:
            fmt.Printf("\n❌ Error: %v\n", event.Error)
        }
    }
}
```

### Event Filtering

```go
// Filter events by type
func createFilteredEventHandler(eventTypes ...dive.ResponseEventType) dive.EventCallback {
    eventSet := make(map[dive.ResponseEventType]bool)
    for _, eventType := range eventTypes {
        eventSet[eventType] = true
    }

    return func(ctx context.Context, event *dive.ResponseEvent) error {
        if !eventSet[event.Type] {
            return nil // Skip this event
        }

        switch event.Type {
        case dive.EventTypeResponseToolCall:
            fmt.Printf("🔧 Tool: %s\n", event.Item.ToolCall.Name)
        case dive.EventTypeResponseToolResult:
            fmt.Printf("✅ Result: %s\n", event.Item.ToolCallResult.Name)
        }

        return nil
    }
}

// Usage
filteredHandler := createFilteredEventHandler(
    dive.EventTypeResponseToolCall,
    dive.EventTypeResponseToolResult,
)

response, err := agent.CreateResponse(
    ctx,
    dive.WithInput("Search for AI news and summarize"),
    dive.WithEventCallback(filteredHandler),
)
```

## Workflow Event Streaming

### Workflow Event Monitoring

```go
func monitorWorkflowExecution(env *environment.Environment) error {
    inputs := map[string]interface{}{
        "topic": "machine learning",
    }

    // Create workflow event handler
    workflowHandler := func(ctx context.Context, event *environment.ExecutionEvent) error {
        switch event.Type {
        case "execution.started":
            fmt.Printf("🚀 Workflow started: %s (ID: %s)\n", 
                      event.WorkflowName, event.ExecutionID)
            
        case "step.started":
            fmt.Printf("▶️  Step started: %s\n", event.StepName)
            fmt.Printf("   Agent: %s\n", event.AgentName)
            
        case "step.completed":
            fmt.Printf("✅ Step completed: %s\n", event.StepName)
            if event.Duration > 0 {
                fmt.Printf("   Duration: %v\n", event.Duration)
            }
            if event.Usage != nil {
                fmt.Printf("   Tokens: %d total\n", event.Usage.TotalTokens())
            }
            
        case "step.failed":
            fmt.Printf("❌ Step failed: %s\n", event.StepName)
            fmt.Printf("   Error: %v\n", event.Error)
            
        case "state.updated":
            fmt.Printf("💾 State updated: %s\n", event.StateName)
            
        case "execution.completed":
            fmt.Printf("🎉 Workflow completed: %s\n", event.WorkflowName)
            fmt.Printf("   Total duration: %v\n", event.Duration)
            
        case "execution.failed":
            fmt.Printf("💥 Workflow failed: %s\n", event.WorkflowName)
            fmt.Printf("   Error: %v\n", event.Error)
        }
        
        return nil
    }

    // Start workflow with event monitoring
    execution, err := env.RunWorkflow(
        context.Background(),
        "Research Pipeline",
        inputs,
        environment.WithEventCallback(workflowHandler),
    )
    if err != nil {
        return err
    }

    // Wait for completion
    result, err := execution.Wait(context.Background())
    if err != nil {
        return err
    }

    fmt.Printf("Final result: %s\n", result.Status)
    return nil
}
```

### Progress Tracking

```go
// Track workflow progress
type ProgressTracker struct {
    TotalSteps     int
    CompletedSteps int
    FailedSteps    int
    CurrentStep    string
    StartTime      time.Time
    mutex          sync.RWMutex
}

func NewProgressTracker() *ProgressTracker {
    return &ProgressTracker{
        StartTime: time.Now(),
    }
}

func (pt *ProgressTracker) HandleEvent(ctx context.Context, event *environment.ExecutionEvent) error {
    pt.mutex.Lock()
    defer pt.mutex.Unlock()

    switch event.Type {
    case "execution.started":
        pt.StartTime = time.Now()
        
    case "step.started":
        pt.CurrentStep = event.StepName
        
    case "step.completed":
        pt.CompletedSteps++
        
    case "step.failed":
        pt.FailedSteps++
    }

    // Calculate and display progress
    if pt.TotalSteps > 0 {
        progress := float64(pt.CompletedSteps) / float64(pt.TotalSteps) * 100
        elapsed := time.Since(pt.StartTime)
        
        fmt.Printf("\rProgress: %.1f%% (%d/%d steps) - %v elapsed - Current: %s",
                   progress, pt.CompletedSteps, pt.TotalSteps, 
                   elapsed.Round(time.Second), pt.CurrentStep)
    }

    return nil
}

func (pt *ProgressTracker) GetProgress() (float64, time.Duration) {
    pt.mutex.RLock()
    defer pt.mutex.RUnlock()
    
    if pt.TotalSteps == 0 {
        return 0, time.Since(pt.StartTime)
    }
    
    progress := float64(pt.CompletedSteps) / float64(pt.TotalSteps) * 100
    return progress, time.Since(pt.StartTime)
}
```

## Real-time UI Updates

### Web UI with Server-Sent Events

```go
// HTTP handler for streaming events to web UI
func handleWorkflowStream(w http.ResponseWriter, r *http.Request) {
    // Set headers for Server-Sent Events
    w.Header().Set("Content-Type", "text/event-stream")
    w.Header().Set("Cache-Control", "no-cache")
    w.Header().Set("Connection", "keep-alive")
    w.Header().Set("Access-Control-Allow-Origin", "*")

    workflowName := r.URL.Query().Get("workflow")
    if workflowName == "" {
        http.Error(w, "workflow parameter required", http.StatusBadRequest)
        return
    }

    // Create event channel
    eventChan := make(chan *environment.ExecutionEvent, 100)
    defer close(eventChan)

    // Start workflow with event streaming
    env := getEnvironment() // Your environment instance
    execution, err := env.RunWorkflow(
        r.Context(),
        workflowName,
        map[string]interface{}{},
        environment.WithEventCallback(func(ctx context.Context, event *environment.ExecutionEvent) error {
            select {
            case eventChan <- event:
            case <-ctx.Done():
            }
            return nil
        }),
    )
    if err != nil {
        http.Error(w, err.Error(), http.StatusInternalServerError)
        return
    }

    // Stream events to client
    flusher, ok := w.(http.Flusher)
    if !ok {
        http.Error(w, "Streaming not supported", http.StatusInternalServerError)
        return
    }

    for {
        select {
        case event := <-eventChan:
            if event == nil {
                return
            }
            
            // Convert event to JSON
            eventJSON, err := json.Marshal(event)
            if err != nil {
                continue
            }
            
            // Send as Server-Sent Event
            fmt.Fprintf(w, "data: %s\n\n", eventJSON)
            flusher.Flush()
            
            // Check if workflow completed
            if event.Type == "execution.completed" || event.Type == "execution.failed" {
                return
            }
            
        case <-r.Context().Done():
            return
        }
    }
}
```

### JavaScript Client

```javascript
// Frontend JavaScript for consuming events
class WorkflowMonitor {
    constructor(workflowName) {
        this.workflowName = workflowName;
        this.eventSource = null;
        this.callbacks = {};
    }

    start() {
        this.eventSource = new EventSource(`/workflow/stream?workflow=${this.workflowName}`);
        
        this.eventSource.onmessage = (event) => {
            const data = JSON.parse(event.data);
            this.handleEvent(data);
        };

        this.eventSource.onerror = (error) => {
            console.error('EventSource failed:', error);
            this.callbacks.error && this.callbacks.error(error);
        };
    }

    handleEvent(event) {
        switch (event.type) {
            case 'execution.started':
                this.updateStatus('Starting workflow...');
                this.callbacks.started && this.callbacks.started(event);
                break;
                
            case 'step.started':
                this.updateStatus(`Running: ${event.step_name}`);
                this.updateProgress(event.step_index, event.total_steps);
                this.callbacks.stepStarted && this.callbacks.stepStarted(event);
                break;
                
            case 'step.completed':
                this.callbacks.stepCompleted && this.callbacks.stepCompleted(event);
                break;
                
            case 'execution.completed':
                this.updateStatus('Completed successfully');
                this.updateProgress(100, 100);
                this.callbacks.completed && this.callbacks.completed(event);
                this.stop();
                break;
                
            case 'execution.failed':
                this.updateStatus(`Failed: ${event.error}`);
                this.callbacks.failed && this.callbacks.failed(event);
                this.stop();
                break;
        }
    }

    updateStatus(status) {
        const statusElement = document.getElementById('workflow-status');
        if (statusElement) {
            statusElement.textContent = status;
        }
    }

    updateProgress(current, total) {
        const progressElement = document.getElementById('workflow-progress');
        if (progressElement) {
            const percentage = (current / total) * 100;
            progressElement.style.width = `${percentage}%`;
            progressElement.textContent = `${Math.round(percentage)}%`;
        }
    }

    on(eventType, callback) {
        this.callbacks[eventType] = callback;
    }

    stop() {
        if (this.eventSource) {
            this.eventSource.close();
            this.eventSource = null;
        }
    }
}

// Usage
const monitor = new WorkflowMonitor('research-pipeline');

monitor.on('started', (event) => {
    console.log('Workflow started:', event);
});

monitor.on('stepCompleted', (event) => {
    console.log('Step completed:', event.step_name);
});

monitor.on('completed', (event) => {
    console.log('Workflow completed successfully');
});

monitor.on('failed', (event) => {
    console.error('Workflow failed:', event.error);
});

monitor.start();
```

### React Component Example

```jsx
import React, { useState, useEffect } from 'react';

const WorkflowMonitor = ({ workflowName, inputs }) => {
    const [status, setStatus] = useState('Ready');
    const [progress, setProgress] = useState(0);
    const [currentStep, setCurrentStep] = useState('');
    const [events, setEvents] = useState([]);
    const [isRunning, setIsRunning] = useState(false);

    useEffect(() => {
        if (!isRunning) return;

        const eventSource = new EventSource(
            `/workflow/stream?workflow=${workflowName}&inputs=${JSON.stringify(inputs)}`
        );

        eventSource.onmessage = (event) => {
            const data = JSON.parse(event.data);
            handleEvent(data);
        };

        eventSource.onerror = (error) => {
            console.error('EventSource error:', error);
            setIsRunning(false);
        };

        return () => {
            eventSource.close();
        };
    }, [isRunning, workflowName, inputs]);

    const handleEvent = (event) => {
        // Add event to list
        setEvents(prev => [...prev, event]);

        switch (event.type) {
            case 'execution.started':
                setStatus('Running');
                setProgress(0);
                break;
                
            case 'step.started':
                setCurrentStep(event.step_name);
                break;
                
            case 'step.completed':
                if (event.total_steps) {
                    const newProgress = (event.completed_steps / event.total_steps) * 100;
                    setProgress(newProgress);
                }
                break;
                
            case 'execution.completed':
                setStatus('Completed');
                setProgress(100);
                setIsRunning(false);
                break;
                
            case 'execution.failed':
                setStatus('Failed');
                setIsRunning(false);
                break;
        }
    };

    const startWorkflow = () => {
        setEvents([]);
        setIsRunning(true);
    };

    const stopWorkflow = () => {
        setIsRunning(false);
    };

    return (
        <div className="workflow-monitor">
            <div className="controls">
                <button 
                    onClick={startWorkflow} 
                    disabled={isRunning}
                    className="btn btn-primary"
                >
                    Start Workflow
                </button>
                <button 
                    onClick={stopWorkflow} 
                    disabled={!isRunning}
                    className="btn btn-secondary"
                >
                    Stop
                </button>
            </div>

            <div className="status">
                <h3>Status: {status}</h3>
                {currentStep && <p>Current Step: {currentStep}</p>}
                
                <div className="progress-bar">
                    <div 
                        className="progress-fill" 
                        style={{ width: `${progress}%` }}
                    >
                        {Math.round(progress)}%
                    </div>
                </div>
            </div>

            <div className="events">
                <h4>Events</h4>
                <div className="event-list">
                    {events.map((event, index) => (
                        <div key={index} className={`event event-${event.type}`}>
                            <span className="timestamp">
                                {new Date(event.timestamp).toLocaleTimeString()}
                            </span>
                            <span className="type">{event.type}</span>
                            <span className="details">
                                {event.step_name || event.workflow_name || 'System'}
                            </span>
                        </div>
                    ))}
                </div>
            </div>
        </div>
    );
};

export default WorkflowMonitor;
```

## Event Aggregation

### Event Statistics

```go
type EventStatistics struct {
    TotalEvents        int64                           `json:"total_events"`
    EventsByType       map[string]int64                `json:"events_by_type"`
    AvgResponseTime    time.Duration                   `json:"avg_response_time"`
    ErrorRate          float64                         `json:"error_rate"`
    ActiveWorkflows    int                             `json:"active_workflows"`
    CompletedToday     int                             `json:"completed_today"`
    TokenUsage         *TokenUsageStats                `json:"token_usage"`
    mutex              sync.RWMutex
}

type TokenUsageStats struct {
    TotalInputTokens  int64 `json:"total_input_tokens"`
    TotalOutputTokens int64 `json:"total_output_tokens"`
    CostEstimate      float64 `json:"cost_estimate"`
}

func NewEventStatistics() *EventStatistics {
    return &EventStatistics{
        EventsByType: make(map[string]int64),
        TokenUsage:   &TokenUsageStats{},
    }
}

func (es *EventStatistics) RecordEvent(event *dive.ResponseEvent) {
    es.mutex.Lock()
    defer es.mutex.Unlock()

    es.TotalEvents++
    es.EventsByType[string(event.Type)]++

    if event.Response != nil && event.Response.Usage != nil {
        usage := event.Response.Usage
        es.TokenUsage.TotalInputTokens += int64(usage.InputTokens)
        es.TokenUsage.TotalOutputTokens += int64(usage.OutputTokens)
        
        // Estimate cost based on token usage (example rates)
        inputCost := float64(usage.InputTokens) * 0.00001  // $0.01 per 1K tokens
        outputCost := float64(usage.OutputTokens) * 0.00003 // $0.03 per 1K tokens
        es.TokenUsage.CostEstimate += inputCost + outputCost
    }
}

func (es *EventStatistics) GetStatistics() EventStatistics {
    es.mutex.RLock()
    defer es.mutex.RUnlock()

    // Create a copy for safe reading
    stats := EventStatistics{
        TotalEvents:     es.TotalEvents,
        EventsByType:    make(map[string]int64),
        AvgResponseTime: es.AvgResponseTime,
        ErrorRate:       es.ErrorRate,
        ActiveWorkflows: es.ActiveWorkflows,
        CompletedToday:  es.CompletedToday,
        TokenUsage: &TokenUsageStats{
            TotalInputTokens:  es.TokenUsage.TotalInputTokens,
            TotalOutputTokens: es.TokenUsage.TotalOutputTokens,
            CostEstimate:      es.TokenUsage.CostEstimate,
        },
    }

    for k, v := range es.EventsByType {
        stats.EventsByType[k] = v
    }

    return stats
}
```

### Event Aggregator Service

```go
type EventAggregator struct {
    statistics     *EventStatistics
    eventBuffers   map[string][]*dive.ResponseEvent
    flushInterval  time.Duration
    bufferSize     int
    mutex          sync.RWMutex
    stopChan       chan struct{}
}

func NewEventAggregator() *EventAggregator {
    ea := &EventAggregator{
        statistics:    NewEventStatistics(),
        eventBuffers:  make(map[string][]*dive.ResponseEvent),
        flushInterval: time.Minute * 5,
        bufferSize:    1000,
        stopChan:      make(chan struct{}),
    }

    // Start background flush routine
    go ea.flushLoop()

    return ea
}

func (ea *EventAggregator) HandleEvent(ctx context.Context, event *dive.ResponseEvent) error {
    ea.mutex.Lock()
    defer ea.mutex.Unlock()

    // Record statistics
    ea.statistics.RecordEvent(event)

    // Buffer events by type for batch processing
    eventType := string(event.Type)
    ea.eventBuffers[eventType] = append(ea.eventBuffers[eventType], event)

    // Flush if buffer is full
    if len(ea.eventBuffers[eventType]) >= ea.bufferSize {
        go ea.flushEventType(eventType)
    }

    return nil
}

func (ea *EventAggregator) flushLoop() {
    ticker := time.NewTicker(ea.flushInterval)
    defer ticker.Stop()

    for {
        select {
        case <-ticker.C:
            ea.flushAll()
        case <-ea.stopChan:
            return
        }
    }
}

func (ea *EventAggregator) flushAll() {
    ea.mutex.Lock()
    defer ea.mutex.Unlock()

    for eventType := range ea.eventBuffers {
        if len(ea.eventBuffers[eventType]) > 0 {
            go ea.flushEventType(eventType)
        }
    }
}

func (ea *EventAggregator) flushEventType(eventType string) {
    ea.mutex.Lock()
    events := ea.eventBuffers[eventType]
    ea.eventBuffers[eventType] = nil
    ea.mutex.Unlock()

    if len(events) == 0 {
        return
    }

    // Process events (store to database, send to analytics, etc.)
    log.Printf("Flushing %d events of type %s", len(events), eventType)
    
    // Example: Store to database
    // database.StoreEvents(events)
    
    // Example: Send to analytics service
    // analytics.SendEvents(events)
}

func (ea *EventAggregator) Stop() {
    close(ea.stopChan)
    ea.flushAll()
}
```

## Monitoring and Alerting

### System Health Monitoring

```go
type HealthMonitor struct {
    metrics       map[string]interface{}
    thresholds    map[string]float64
    alertHandlers []AlertHandler
    mutex         sync.RWMutex
}

type AlertHandler interface {
    HandleAlert(alert Alert) error
}

type Alert struct {
    Severity    string    `json:"severity"`
    Message     string    `json:"message"`
    Metric      string    `json:"metric"`
    Value       float64   `json:"value"`
    Threshold   float64   `json:"threshold"`
    Timestamp   time.Time `json:"timestamp"`
}

func NewHealthMonitor() *HealthMonitor {
    return &HealthMonitor{
        metrics: make(map[string]interface{}),
        thresholds: map[string]float64{
            "error_rate":        0.05,  // 5% error rate
            "avg_response_time": 30000, // 30 second response time
            "queue_depth":       100,   // 100 queued requests
        },
    }
}

func (hm *HealthMonitor) HandleEvent(ctx context.Context, event *dive.ResponseEvent) error {
    hm.mutex.Lock()
    defer hm.mutex.Unlock()

    // Track response times
    if event.Type == dive.EventTypeResponseCompleted && event.Response != nil {
        duration := event.Response.FinishedAt.Sub(event.Response.CreatedAt)
        hm.updateMetric("avg_response_time", float64(duration.Milliseconds()))
    }

    // Track error rates
    if event.Type == dive.EventTypeResponseFailed {
        hm.incrementCounter("error_count")
        errorRate := hm.calculateErrorRate()
        hm.updateMetric("error_rate", errorRate)
        
        if errorRate > hm.thresholds["error_rate"] {
            alert := Alert{
                Severity:  "warning",
                Message:   fmt.Sprintf("High error rate detected: %.2f%%", errorRate*100),
                Metric:    "error_rate",
                Value:     errorRate,
                Threshold: hm.thresholds["error_rate"],
                Timestamp: time.Now(),
            }
            hm.triggerAlert(alert)
        }
    }

    return nil
}

func (hm *HealthMonitor) updateMetric(name string, value float64) {
    // Implement moving average or other aggregation logic
    hm.metrics[name] = value
}

func (hm *HealthMonitor) incrementCounter(name string) {
    if counter, exists := hm.metrics[name]; exists {
        hm.metrics[name] = counter.(int) + 1
    } else {
        hm.metrics[name] = 1
    }
}

func (hm *HealthMonitor) calculateErrorRate() float64 {
    errors, errorsExist := hm.metrics["error_count"]
    total, totalExists := hm.metrics["total_requests"]
    
    if !errorsExist || !totalExists {
        return 0
    }
    
    return float64(errors.(int)) / float64(total.(int))
}

func (hm *HealthMonitor) triggerAlert(alert Alert) {
    for _, handler := range hm.alertHandlers {
        go handler.HandleAlert(alert)
    }
}

// Slack alert handler
type SlackAlertHandler struct {
    WebhookURL string
}

func (s *SlackAlertHandler) HandleAlert(alert Alert) error {
    message := map[string]interface{}{
        "text": fmt.Sprintf("🚨 *%s Alert*\n%s\nValue: %.2f (Threshold: %.2f)",
                           strings.Title(alert.Severity),
                           alert.Message,
                           alert.Value,
                           alert.Threshold),
        "channel": "#alerts",
    }
    
    // Send to Slack webhook
    return sendSlackMessage(s.WebhookURL, message)
}
```

### Performance Metrics Dashboard

```go
// HTTP endpoint for metrics dashboard
func metricsHandler(w http.ResponseWriter, r *http.Request) {
    aggregator := getEventAggregator() // Your aggregator instance
    stats := aggregator.statistics.GetStatistics()

    // Add real-time metrics
    metrics := map[string]interface{}{
        "statistics": stats,
        "health": map[string]interface{}{
            "uptime":             time.Since(startTime),
            "active_connections": getActiveConnections(),
            "memory_usage":       getMemoryUsage(),
            "cpu_usage":          getCPUUsage(),
        },
        "recent_events": getRecentEvents(100),
    }

    w.Header().Set("Content-Type", "application/json")
    json.NewEncoder(w).Encode(metrics)
}

// WebSocket endpoint for real-time metrics
func metricsWebSocketHandler(w http.ResponseWriter, r *http.Request) {
    conn, err := upgrader.Upgrade(w, r, nil)
    if err != nil {
        log.Printf("WebSocket upgrade failed: %v", err)
        return
    }
    defer conn.Close()

    // Send metrics updates every second
    ticker := time.NewTicker(time.Second)
    defer ticker.Stop()

    for {
        select {
        case <-ticker.C:
            aggregator := getEventAggregator()
            stats := aggregator.statistics.GetStatistics()
            
            if err := conn.WriteJSON(stats); err != nil {
                log.Printf("WebSocket write failed: %v", err)
                return
            }
            
        case <-r.Context().Done():
            return
        }
    }
}
```

## Best Practices

### 1. Event Handler Design

```go
// Good: Lightweight, non-blocking event handlers
func goodEventHandler(ctx context.Context, event *dive.ResponseEvent) error {
    // Process quickly and return
    switch event.Type {
    case dive.EventTypeResponseCompleted:
        // Quick logging
        log.Printf("Response completed: %s", event.Response.ID)
        
        // Send to background processor
        select {
        case eventQueue <- event:
        default:
            // Don't block if queue is full
        }
    }
    
    return nil
}

// Avoid: Heavy processing in event handlers
func badEventHandler(ctx context.Context, event *dive.ResponseEvent) error {
    // DON'T: Heavy database operations
    database.ComplexQuery(event)
    
    // DON'T: External API calls
    sendToExternalService(event)
    
    // DON'T: File I/O operations
    writeToFile(event)
    
    return nil
}
```

### 2. Error Handling

```go
func robustEventHandler(ctx context.Context, event *dive.ResponseEvent) error {
    defer func() {
        if r := recover(); r != nil {
            log.Printf("Event handler panic: %v", r)
        }
    }()

    // Handle errors gracefully
    if err := processEvent(event); err != nil {
        log.Printf("Event processing error: %v", err)
        
        // Don't propagate errors that would stop event streaming
        // Only return errors for critical failures
        return nil
    }
    
    return nil
}
```

### 3. Resource Management

```go
// Proper resource management for event streams
func manageEventStream() {
    stream, err := agent.StreamResponse(ctx, dive.WithInput("Hello"))
    if err != nil {
        return
    }
    
    // Always close streams
    defer stream.Close()
    
    // Use context for cancellation
    ctx, cancel := context.WithTimeout(context.Background(), time.Minute*5)
    defer cancel()
    
    // Process events with timeout
    for {
        select {
        case event, ok := <-stream.Events():
            if !ok {
                return // Stream closed
            }
            handleEvent(event)
            
        case <-ctx.Done():
            return // Timeout or cancellation
        }
    }
}
```

### 4. Event Buffering

```go
// Buffer events to prevent blocking
type EventBuffer struct {
    events   chan *dive.ResponseEvent
    handlers []dive.EventCallback
    workers  int
}

func NewEventBuffer(size, workers int) *EventBuffer {
    eb := &EventBuffer{
        events:  make(chan *dive.ResponseEvent, size),
        workers: workers,
    }
    
    // Start worker goroutines
    for i := 0; i < workers; i++ {
        go eb.worker()
    }
    
    return eb
}

func (eb *EventBuffer) worker() {
    for event := range eb.events {
        for _, handler := range eb.handlers {
            if err := handler(context.Background(), event); err != nil {
                log.Printf("Event handler error: %v", err)
            }
        }
    }
}

func (eb *EventBuffer) HandleEvent(ctx context.Context, event *dive.ResponseEvent) error {
    select {
    case eb.events <- event:
        return nil
    default:
        // Buffer full, drop event or log warning
        log.Printf("Event buffer full, dropping event: %s", event.Type)
        return nil
    }
}
```

### 5. Testing Event Handlers

```go
func TestEventHandler(t *testing.T) {
    var receivedEvents []*dive.ResponseEvent
    
    handler := func(ctx context.Context, event *dive.ResponseEvent) error {
        receivedEvents = append(receivedEvents, event)
        return nil
    }
    
    // Create test agent with handler
    agent, err := agent.New(agent.Options{
        Name:  "Test Agent",
        Model: &MockLLM{},
    })
    require.NoError(t, err)
    
    // Test event generation
    response, err := agent.CreateResponse(
        context.Background(),
        dive.WithInput("test"),
        dive.WithEventCallback(handler),
    )
    require.NoError(t, err)
    
    // Verify events were received
    assert.Greater(t, len(receivedEvents), 0)
    assert.Equal(t, dive.EventTypeResponseCreated, receivedEvents[0].Type)
}
```

## Next Steps

- [Agent Guide](agents.md) - Learn about agent events
- [Workflow Guide](workflows.md) - Understand workflow events  
- [Monitoring Guide](monitoring.md) - Advanced monitoring patterns
- [API Reference](../api/core.md) - Event system APIs