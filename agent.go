package agent

import (
	"context"
	"encoding/json"
	"errors"
	"fmt"
	"os"
	"path/filepath"
	"strings"
	"time"

	"github.com/getstingrai/agents/llm"
)

const ModelClaude3Dot5Sonnet20241022 = "claude-3-5-sonnet-20241022"

type ConversationLogger interface {
	LogConversation(
		ctx context.Context,
		agent *Agent,
		messages []*llm.Message,
		response *llm.Response,
	) error
}

type AgentSpec struct {
	Name              string   `json:"name"`
	Role              string   `json:"role"`
	Goal              string   `json:"goal"`
	Backstory         string   `json:"backstory"`
	Model             string   `json:"model"`
	CanDelegate       bool     `json:"can_delegate"`
	Subordinates      []string `json:"subordinates"`
	AcceptsDelegation bool     `json:"accepts_delegation"`
	Temperature       *float64 `json:"temperature"`
	MaxTokens         int      `json:"max_tokens"`
	Caching           bool     `json:"caching"`
}

// Agent represents a single AI agent with a specific role and capabilities
type Agent struct {
	name string

	// Role describes the agent's specialized function
	role         string
	roleTemplate string

	// Goal describes what the agent aims to accomplish
	goal         string
	goalTemplate string

	// Backstory provides context and personality for the agent
	backstory         string
	backstoryTemplate string

	// Model is the LLM model to use for the agent
	model string

	// CanDelegate indicates if this agent can assign work to others
	canDelegate bool

	// acceptsDelegation is true if this agent can accept delegation
	acceptsDelegation bool

	// Team is the team this agent is a part of
	team *Team

	// History of tasks
	history []TaskResult

	// Temperature is the temperature to use for the agent
	temperature *float64

	// MaxTokens is the maximum number of tokens to use for the agent
	maxTokens int

	// Caching control for LLM interactions
	caching bool

	// Subordinates is a list of agents that this agent can delegate tasks to
	subordinates []string
}

func NewAgent(spec AgentSpec) *Agent {
	if spec.Model == "" {
		spec.Model = ModelClaude3Dot5Sonnet20241022
	}
	if spec.MaxTokens <= 0 {
		spec.MaxTokens = 4096
	}
	return &Agent{
		name:              spec.Name,
		role:              spec.Role,
		roleTemplate:      spec.Role,
		goal:              spec.Goal,
		goalTemplate:      spec.Goal,
		backstory:         spec.Backstory,
		backstoryTemplate: spec.Backstory,
		model:             spec.Model,
		canDelegate:       spec.CanDelegate,
		acceptsDelegation: spec.AcceptsDelegation,
		temperature:       spec.Temperature,
		maxTokens:         spec.MaxTokens,
		caching:           spec.Caching,
		subordinates:      spec.Subordinates,
	}
}

func (a *Agent) Name() string {
	return a.name
}

func (a *Agent) Role() string {
	if a.role == "" {
		return a.name
	}
	return a.role
}

func (a *Agent) Backstory() string {
	return a.backstory
}

func (a *Agent) Goal() string {
	return a.goal
}

func (a *Agent) History() []TaskResult {
	return a.history
}

func (a *Agent) Team() *Team {
	return a.team
}

func (a *Agent) SetTeam(team *Team) {
	a.team = team
}

func (a *Agent) Subordinates() []string {
	return a.subordinates
}

func (a *Agent) InterpolateInputs(input any) error {
	var err error
	if a.role, err = interpolateTemplate("role", a.roleTemplate, input); err != nil {
		return err
	}
	if a.goal, err = interpolateTemplate("goal", a.goalTemplate, input); err != nil {
		return err
	}
	if a.backstory, err = interpolateTemplate("backstory", a.backstoryTemplate, input); err != nil {
		return err
	}
	return nil
}

// respond sends a message to the agent's brain and returns the response
func (a *Agent) respond(ctx context.Context, messages ...*llm.Message) (*llm.Response, error) {
	return nil, errors.New("not implemented")
}

func (a *Agent) ExecuteTask(ctx context.Context, task *Task, deps []TaskResult) TaskResult {
	result := a.executeTask(ctx, task, deps)
	a.history = append(a.history, result)
	return result
}

// ExecuteTask handles the execution of a single task with all necessary context
func (a *Agent) executeTask(ctx context.Context, task *Task, deps []TaskResult) TaskResult {

	// Exclude dependencies that were generated by this agent. That information
	// will already be in this agent's conversation history.
	var processedDeps []TaskResult
	for _, dep := range deps {
		if dep.Task.Agent().Name() != a.Name() {
			processedDeps = append(processedDeps, dep)
		}
	}

	// Build the complete prompt
	prompt, err := a.buildTaskPrompt(task, processedDeps)
	if err != nil {
		return TaskResult{Task: task, Error: err}
	}

	// Send the request to the agent
	resp, err := a.respond(ctx, llm.NewUserMessage(prompt))
	if err != nil {
		return TaskResult{Task: task, Error: err}
	}

	output, err := parseResponse(
		task.OutputFormat(),
		task.OutputObject(),
		resp.Message().Text(),
	)
	if err != nil {
		return TaskResult{
			Task:  task,
			Error: err,
		}
	}

	if task.outputFile != "" {
		if err := os.MkdirAll(filepath.Dir(task.outputFile), 0755); err != nil {
			return TaskResult{
				Task:  task,
				Error: fmt.Errorf("failed to create output directory: %w", err),
			}
		}
		if err := os.WriteFile(task.outputFile, []byte(output.Content), 0644); err != nil {
			return TaskResult{
				Task:  task,
				Error: fmt.Errorf("failed to write output to file: %w", err),
			}
		}
	}

	return TaskResult{
		Task:   task,
		Output: output,
	}
}

func (a *Agent) buildTaskPrompt(task *Task, deps []TaskResult) (string, error) {
	taskPrompt, err := interpolateTemplate(
		"task",
		taskTemplate,
		map[string]any{
			"Agent":        &AgentTemplateProxy{Agent: a},
			"Task":         task,
			"Dependencies": deps,
			"CurrentDate":  time.Now().Format("January 2, 2006"),
		},
	)
	if err != nil {
		return "", err
	}
	return strings.TrimSpace(taskPrompt), nil
}

func (a *Agent) SystemPrompt() (string, error) {
	return interpolateTemplate(
		"system_prompt",
		systemPromptTemplate,
		&AgentTemplateProxy{Agent: a},
	)
}

func parseResponse(format OutputFormat, object interface{}, responseText string) (TaskOutput, error) {
	// Ensure final answer is not empty
	if strings.TrimSpace(responseText) == "" {
		return TaskOutput{}, fmt.Errorf("empty final answer")
	}

	if format != OutputJSON {
		return TaskOutput{
			Content:   responseText,
			Format:    format,
			Reasoning: "",
		}, nil
	}

	// Find the first "[" or "{" character. This is the start of the JSON.
	// Then look for the corresponding closing character.
	firstBracket := strings.Index(responseText, "[")
	firstBrace := strings.Index(responseText, "{")
	if firstBrace == -1 && firstBracket == -1 {
		return TaskOutput{}, fmt.Errorf("no json found in response")
	}

	isArray := firstBracket != -1 && (firstBrace == -1 || firstBracket < firstBrace)

	// Find the start of the JSON content
	var startIndex int
	if isArray {
		startIndex = firstBracket
	} else {
		startIndex = firstBrace
	}

	// Find the matching closing bracket/brace
	closeChar := map[bool]rune{true: ']', false: '}'}[isArray]
	lastIndex := strings.LastIndex(responseText, string(closeChar))

	if lastIndex == -1 {
		return TaskOutput{}, fmt.Errorf("malformed JSON: no closing character found")
	}

	endIndex := lastIndex + 1

	// Extract the JSON content and any preceding text as reasoning
	thought := strings.TrimSpace(responseText[:startIndex])
	finalAnswer := responseText[startIndex:endIndex]

	finalAnswer = strings.TrimSpace(finalAnswer)
	if err := json.Unmarshal([]byte(finalAnswer), object); err != nil {
		return TaskOutput{}, fmt.Errorf("invalid json output: %w", err)
	}

	return TaskOutput{
		Content:   finalAnswer,
		Format:    format,
		Object:    object,
		Reasoning: thought,
	}, nil
}
