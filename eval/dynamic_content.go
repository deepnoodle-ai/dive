package eval

import (
	"context"
	"encoding/json"
	"fmt"
	_ "image/jpeg"
	_ "image/png"
	"os"
	"os/exec"
	"path/filepath"

	"github.com/deepnoodle-ai/dive/llm"
)

// DynamicContent is an interface that allows content to be dynamically
// generated at runtime during workflow execution.
type DynamicContent interface {
	Content(ctx context.Context, inputs map[string]any) ([]llm.Content, error)
}

//// ScriptPathContent /////////////////////////////////////////////////////////

// ScriptPathContent represents content that is dynamically generated by executing
// an external script at runtime.
type ScriptPathContent struct {
	DynamicFrom string `json:"dynamic_from"`
	BasePath    string `json:"base_path,omitempty"`
}

func (c *ScriptPathContent) Type() llm.ContentType {
	return llm.ContentTypeDynamic
}

func (c *ScriptPathContent) Content(ctx context.Context, globals map[string]any) ([]llm.Content, error) {
	if globals == nil {
		globals = make(map[string]any)
	}
	// Resolve the script path
	resolvedPath := c.DynamicFrom
	if !filepath.IsAbs(c.DynamicFrom) && c.BasePath != "" {
		resolvedPath = filepath.Join(c.BasePath, c.DynamicFrom)
	}
	// Check if file exists
	if _, err := os.Stat(resolvedPath); err != nil {
		return nil, fmt.Errorf("script file not found: %s", resolvedPath)
	}
	// Execute as external script and expect JSON output
	return c.executeExternalScript(ctx, resolvedPath, globals)
}

// executeExternalScript executes an external script and parses JSON output
func (c *ScriptPathContent) executeExternalScript(ctx context.Context, scriptPath string, globals map[string]any) ([]llm.Content, error) {
	cmd := exec.CommandContext(ctx, scriptPath)

	env := os.Environ()
	// TODO: insert variables?
	cmd.Env = env

	output, err := cmd.Output()
	if err != nil {
		return nil, fmt.Errorf("script execution failed: %w", err)
	}

	var items []json.RawMessage
	if err := json.Unmarshal(output, &items); err != nil {
		return nil, fmt.Errorf("failed to parse script JSON output: %w", err)
	}
	var resultItems []llm.Content
	for _, item := range items {
		resultItem, err := llm.UnmarshalContent(item)
		if err != nil {
			return nil, fmt.Errorf("failed to parse script JSON output: %w", err)
		}
		resultItems = append(resultItems, resultItem)
	}
	return resultItems, nil
}
